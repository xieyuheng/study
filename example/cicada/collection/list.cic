import * from "../basic/bool.cic"
import * from "../basic/nat.cic"

datatype list_t(A: type) {
  case null_t(A: type)
  case cons_t(A: type, head: A, tail: list_t(A))
}

fn list_length(list: list_t): nat_t = {
  list choice {
    case null_t => zero_t
    case cons_t => succ_t(list_length(list.tail))
  }
}

fn list_append(A: type, x: list_t(A), y: list_t(A)): list_t(A) = {
  x choice {
    case null_t => y
    case cons_t => cons_t(A, x.head, list_append(A, x.tail, y))
  }
}

fn list_map(A: type, B: type, f: (A) -> B, list: list_t(A)): list_t(B) = {
  list choice {
    case null_t => list
    case cons_t => cons_t(A, f(list.head), list_map(A, B, f, list.tail))
  }
}

let three_zeros: list_t(nat_t) =
  cons_t(nat_t, zero,
    cons_t(nat_t, zero,
      cons_t(nat_t, zero,
        null_t(nat_t))))

let three_ones: list_t(nat_t) =
  cons_t(nat_t, one,
    cons_t(nat_t, one,
      cons_t(nat_t, one,
        null_t(nat_t))))

@assert_eq list_length(null_t) zero
@assert_eq list_length(three_zeros) three
@assert_eq list_length(list_append(nat_t, three_zeros, three_ones)) six
@assert_eq list_map(nat_t, nat_t, nat_add(one), three_zeros) three_ones
