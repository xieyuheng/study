import * from "../basic/bool.cic"
import * from "../basic/nat.cic"

datatype vec_t(A: type_t, length: nat_t) {
  case vec_null_t(
    A: type_t,
    length: nat_t = zero_t)
  case vec_cons_t(
    A: type_t,
    prev: nat_t,
    length: nat_t = succ_t(prev),
    head: A,
    tail: vec_t(A, prev))
}

fn vec_append(
  A: type_t,
  m: nat_t,
  n: nat_t,
  x: vec_t(A, m),
  y: vec_t(A, n),
): vec_t(A, n) = {
  x choice {
    case vec_null_t => y
    case vec_cons_t => vec_cons_t(
      A, nat_add(m.prev, n),
      x.head, vec_append(A, m.prev, n, x.tail, y))
  }
}

fn vec_map(A: type_t, B: type_t, n: nat_t, f: (A) -> B, vec: vec_t(A, n)): vec_t(B, n) = {
  vec choice {
    case vec_null_t => vec
    case vec_cons_t => vec_cons_t(
      B, n.prev,
      f(vec.head), vec_map(A, B, n.prev, f, vec.tail))
  }
}

@assert_eq vec_null_t(nat_t).A nat_t
@assert_eq vec_null_t(nat_t).length zero

let three_zeros: vec_t(nat_t, three) =
  vec_cons_t(nat_t, two, zero,
    vec_cons_t(nat_t, one, zero,
      vec_cons_t(nat_t, zero, zero,
        vec_null_t(nat_t))))

let three_ones: vec_t(nat_t, three) =
  vec_cons_t(nat_t, two, one,
    vec_cons_t(nat_t, one, one,
      vec_cons_t(nat_t, zero, one,
        vec_null_t(nat_t))))

@assert_eq three_zeros.A nat_t
@assert_eq three_zeros.length three

@assert_eq vec_append(nat_t, three, three, three_zeros, three_ones).length six

@assert_eq vec_map(nat_t, nat_t, three, nat_add(one), three_zeros) three_ones
